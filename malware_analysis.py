import pefile
import networkx as nx
import matplotlib.pyplot as plt
import re
import subprocess

def analyze_malware(file_path):
    """
    Analyze a malware sample and extract relevant information.
    """
    # Check if the file is a PE executable
    output = subprocess.check_output(['file', file_path]).decode('utf-8')
    if 'PE32 executable' not in output:
        print(f"{file_path} is not a valid PE executable.")
        return

    pe = pefile.PE(file_path)
    
    # Extract API calls
    api_calls = extract_api_calls(pe)
    print("API Calls:")
    for call in api_calls:
        print(call)
    
    # Extract registry keys
    registry_keys = extract_registry_keys(pe)
    print("\nRegistry Keys:")
    for key in registry_keys:
        print(key)
    
    # Extract file operations
    file_operations = extract_file_operations(pe)
    print("\nFile Operations:")
    for operation in file_operations:
        print(operation)

def reverse_engineer(file_path):
    """
    Reverse-engineer the malware to identify its function calls, data flows, and potential entry points.
    """
    # Check if the file is a PE executable
    output = subprocess.check_output(['file', file_path]).decode('utf-8')
    if 'PE32 executable' not in output:
        print(f"{file_path} is not a valid PE executable.")
        return

    pe = pefile.PE(file_path)
    
    # Disassemble the code sections
    disassembled_code = disassemble_code(pe)
    print("Disassembled Code:")
    print(disassembled_code)
    
    # Construct a control flow graph
    cfg = construct_cfg(disassembled_code)
    print("\nControl Flow Graph:")
    print(cfg.nodes())
    print(cfg.edges())
    
    # Identify potential entry points
    entry_points = identify_entry_points(cfg)
    print("\nPotential Entry Points:")
    for entry_point in entry_points:
        print(entry_point)

def identify_iocs(file_path):
    """
    Identify indicators of compromise (IoCs) such as IP addresses, domain names, and code patterns.
    """
    # Check if the file is a PE executable
    output = subprocess.check_output(['file', file_path]).decode('utf-8')
    if 'PE32 executable' not in output:
        print(f"{file_path} is not a valid PE executable.")
        return

    pe = pefile.PE(file_path)
    
    # Extract strings from the executable
    strings = extract_strings(pe)
    
    # Identify IP addresses
    ip_addresses = identify_ip_addresses(strings)
    print("IP Addresses:")
    for ip in ip_addresses:
        print(ip)
    
    # Identify domain names
    domain_names = identify_domain_names(strings)
    print("\nDomain Names:")
    for domain in domain_names:
        print(domain)
    
    # Identify code patterns
    code_patterns = identify_code_patterns(disassemble_code(pe))
    print("\nCode Patterns:")
    for pattern in code_patterns:
        print(pattern)

def visualize_cfg(cfg):
    """
    Visualize the control flow graph using NetworkX and Matplotlib.
    """
    pos = nx.spring_layout(cfg)
    nx.draw_networkx_nodes(cfg, pos, node_size=700)
    nx.draw_networkx_edges(cfg, pos, edge_color='r', arrows=True)
    nx.draw_networkx_labels(cfg, pos, font_size=10, font_family='sans-serif')
    plt.axis('off')
    plt.show()

# Helper functions
def extract_api_calls(pe):
    api_calls = []
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        for imp in entry.imports:
            api_calls.append(imp.name.decode('utf-8'))
    return api_calls

def extract_registry_keys(pe):
    registry_keys = []
    for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        if rsrc.name is not None and rsrc.name.string.decode('utf-8').startswith('REGISTRY'):
            registry_keys.append(rsrc.name.string.decode('utf-8'))
    return registry_keys

def extract_file_operations(pe):
    file_operations = []
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        for imp in entry.imports:
            if 'CreateFile' in imp.name.decode('utf-8'):
                file_operations.append('CreateFile')
            elif 'WriteFile' in imp.name.decode('utf-8'):
                file_operations.append('WriteFile')
            elif 'ReadFile' in imp.name.decode('utf-8'):
                file_operations.append('ReadFile')
    return file_operations

def disassemble_code(pe):
    disassembled_code = ""
    ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    ep_ava = ep + pe.OPTIONAL_HEADER.ImageBase
    
    # Extract the code section
    for section in pe.sections:
        if section.contains_rva(ep):
            code_section = section
            break
    
    # Write the code section to a temporary file
    with open("temp_code.bin", "wb") as f:
        f.write(code_section.get_data())
    
    # Use a disassembler to disassemble the code
    # Note: Replace 'disassembler_command' with the actual command for your preferred disassembler
    output = subprocess.check_output(['disassembler_command', 'temp_code.bin']).decode('utf-8')
    
    # Process the disassembled output
    for line in output.split('\n'):
        if line.startswith('0x'):
            disassembled_code += line + '\n'
    
    # Remove the temporary file
    subprocess.call(['rm', 'temp_code.bin'])
    
    return disassembled_code

def construct_cfg(disassembled_code):
    cfg = nx.DiGraph()
    block_start = None
    
    for line in disassembled_code.split('\n'):
        if line.startswith('0x'):
            address = int(line.split(':')[0], 16)
            if block_start is None:
                block_start = address
            else:
                cfg.add_edge(block_start, address)
                block_start = address
    
    return cfg

def identify_entry_points(cfg):
    entry_points = []
    for node in cfg.nodes():
        if cfg.in_degree(node) == 0:
            entry_points.append(node)
    return entry_points

def extract_strings(pe):
    strings = []
    for section in pe.sections:
        if section.Name.decode('utf-8').startswith('.rdata'):
            data = section.get_data()
            strings += re.findall(b"[\x20-\x7e]{4,}", data)
    return [s.decode('utf-8') for s in strings]

def identify_ip_addresses(strings):
    ip_pattern = re.compile(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
    return [s for s in strings if ip_pattern.match(s)]

def identify_domain_names(strings):
    domain_pattern = re.compile(r'[a-zA-Z0-9]+\.[a-zA-Z]{2,}')
    return [s for s in strings if domain_pattern.match(s)]

def identify_code_patterns(disassembled_code):
    patterns = []
    if 'XOR' in disassembled_code:
        patterns.append('XOR Encryption')
    if 'GetProcAddress' in disassembled_code:
        patterns.append('Dynamic API Resolution')
    if 'CreateThread' in disassembled_code:
        patterns.append('Multithreading')
    return patterns

# Example usage
if __name__ == "__main__":
    file_path = "path/to/sample/malware.exe"
    analyze_malware(file_path)
    reverse_engineer(file_path)
    identify_iocs(file_path)
    cfg = construct_cfg(disassemble_code(pefile.PE(file_path)))
    visualize_cfg(cfg)
